{
	"name": "openData_Providers",
	"properties": {
		"folder": {
			"name": "openData"
		},
		"type": "MappingDataFlow",
		"typeProperties": {
			"sources": [
				{
					"dataset": {
						"referenceName": "cosmosDb_Ukrlp_Backup",
						"type": "DatasetReference"
					},
					"name": "Providers"
				},
				{
					"dataset": {
						"referenceName": "cosmosDb_Courses_Backup",
						"type": "DatasetReference"
					},
					"name": "Courses"
				}
			],
			"sinks": [
				{
					"dataset": {
						"referenceName": "openData_Cache_Providers",
						"type": "DatasetReference"
					},
					"name": "Cache"
				}
			],
			"transformations": [
				{
					"name": "FilterActive"
				},
				{
					"name": "FlattenContacts"
				},
				{
					"name": "SplitContacts"
				},
				{
					"name": "BackfillLegalContacts"
				},
				{
					"name": "MergeContacts"
				},
				{
					"name": "CreateContactAddress"
				},
				{
					"name": "Transform"
				},
				{
					"name": "SortedProviders"
				},
				{
					"name": "FlattenCourseRuns"
				},
				{
					"name": "HasLiveCourses"
				}
			],
			"script": "source(output(\n\t\tUnitedKingdomProviderReferenceNumber as string,\n\t\tProviderName as string,\n\t\tTradingName as string,\n\t\tProviderStatus as string,\n\t\tProviderType as integer,\n\t\tProviderContact as (ContactType as string, ContactAddress as (SAON as (Description as string), PAON as (Description as string), StreetDescription as string, UniqueStreetReferenceNumber as string, Locality as string, Items as string[], ItemsElementName as string[], PostTown as string, PostCode as string, UniquePropertyReferenceNumber as string), ContactPersonalDetails as (PersonNameTitle as string, PersonGivenName as string, PersonFamilyName as string, PersonNameSuffix as string, PersonRequestedName as string), ContactRole as string, ContactTelephone1 as string, ContactTelephone2 as string, ContactFax as string, ContactWebsiteAddress as string, ContactEmail as string, LastUpdated as string)[],\n\t\tProviderVerificationDate as string,\n\t\tProviderVerificationDateSpecified as boolean,\n\t\tExpiryDateSpecified as boolean,\n\t\tProviderAssociations as string,\n\t\tProviderAliases as (ProviderAlias as string, LastUpdated as string)[],\n\t\tVerificationDetails as (VerificationAuthority as string, VerificationID as string)[],\n\t\tid as string,\n\t\tDateUpdated as string,\n\t\tDateDownloaded as string,\n\t\tStatus as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tlimit: 10,\n\tinferDriftedColumnTypes: true) ~> Providers\nsource(output(\n\t\tid as string,\n\t\tCourseId as string,\n\t\tQualificationCourseTitle as string,\n\t\tLearnAimRef as string,\n\t\tNotionalNVQLevelv2 as string,\n\t\tAwardOrgCode as string,\n\t\tQualificationType as string,\n\t\tProviderUKPRN as string,\n\t\tCourseDescription as string,\n\t\tEntryRequirements as string,\n\t\tWhatYoullLearn as string,\n\t\tHowYoullLearn as string,\n\t\tWhatYoullNeed as string,\n\t\tHowYoullBeAssessed as string,\n\t\tWhereNext as string,\n\t\tAdultEducationBudget as boolean,\n\t\tAdvancedLearnerLoan as boolean,\n\t\tCourseRuns as (id as string, CourseInstanceId as string, VenueId as string, CourseName as string, ProviderCourseID as string, DeliveryMode as string, FlexibleStartDate as boolean, StartDate as string, CourseURL as string, Cost as string, CostDescription as string, DurationUnit as string, DurationValue as string, StudyMode as string, AttendancePattern as string, National as boolean, Regions as string[], RecordStatus as string, CreatedDate as string, CreatedBy as string, UpdatedDate as string, UpdatedBy as string, SubRegions as string, BulkUploadErrors as string)[],\n\t\tCourseStatus as string,\n\t\tCreatedDate as string,\n\t\tCreatedBy as string,\n\t\tUpdatedDate as string,\n\t\tIsValid as boolean,\n\t\tUpdatedBy as string,\n\t\tBulkUploadErrors as string[],\n\t\tLarlessReason as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false) ~> Courses\nProviders filter((ProviderType == 1 || ProviderType == 3)\r\n    && (Status == 1 || ProviderStatus == \"Active\")\r\n    && !(isNull(ProviderContact[1]))) ~> FilterActive\nHasLiveCourses foldDown(unroll(ProviderContact),\n\tmapColumn(\n\t\tUnitedKingdomProviderReferenceNumber,\n\t\tProviderName,\n\t\tTradingName,\n\t\tProviderStatus,\n\t\tProviderType,\n\t\tContactType = ProviderContact.ContactType,\n\t\tContactAddress = ProviderContact.ContactAddress,\n\t\tContactRole = ProviderContact.ContactRole,\n\t\tContactTelephone1 = ProviderContact.ContactTelephone1,\n\t\tContactTelephone2 = ProviderContact.ContactTelephone2,\n\t\tContactFax = ProviderContact.ContactFax,\n\t\tContactWebsiteAddress = ProviderContact.ContactWebsiteAddress,\n\t\tContactEmail = ProviderContact.ContactEmail,\n\t\tStatus\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> FlattenContacts\nFlattenContacts split(ContactType == \"P\",\n\tContactType == \"L\",\n\tdisjoint: false) ~> SplitContacts@(PrimaryContact, LegalContact, OtherContact)\nSplitContacts@LegalContact, SplitContacts@PrimaryContact exists(SplitContacts@LegalContact@ProviderUkprn\r\n == SplitContacts@PrimaryContact@ProviderUkprn,\n\tnegate:true,\n\tbroadcast: 'auto')~> BackfillLegalContacts\nSplitContacts@PrimaryContact, BackfillLegalContacts union(byName: true)~> MergeContacts\nMergeContacts derive(ContactAddress1 = concatWS(\r\n    \", \",\r\n    iif(!isNull(ContactAddress.SAON.Description) && ContactAddress.SAON.Description != \"null\", \r\n        ContactAddress.SAON.Description\r\n    ), \r\n    iif(!isNull(ContactAddress.PAON.Description) && ContactAddress.PAON.Description != \"null\", \r\n        ContactAddress.PAON.Description\r\n    ),\r\n    iif(!isNull(ContactAddress.StreetDescription) && ContactAddress.StreetDescription != \"null\", \r\n        ContactAddress.StreetDescription\r\n    )\r\n),\n\t\tContactAddress2 = ContactAddress.Locality,\n\t\tContactTown = iif(!isNull(ContactAddress.PostTown), ContactAddress.PostTown, ContactAddress.Items[1]),\n\t\tContactPostcode = ContactAddress.PostCode,\n\t\tContactPhone = iif(!isNull(ContactTelephone1), ContactTelephone1, ContactTelephone2)) ~> CreateContactAddress\nCreateContactAddress select(mapColumn(\n\t\tProviderUkprn,\n\t\tProviderName,\n\t\tTradingName,\n\t\tContactType,\n\t\tContactAddress1,\n\t\tContactAddress2,\n\t\tContactTown,\n\t\tContactPostcode,\n\t\tContactWebsite = ContactWebsiteAddress,\n\t\tContactEmail,\n\t\tContactPhone\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> Transform\nTransform sort(asc(ProviderUkprn, true)) ~> SortedProviders\nCourses foldDown(unroll(CourseRuns),\n\tmapColumn(\n\t\tProviderUKPRN,\n\t\tRecordStatus = CourseRuns.RecordStatus\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> FlattenCourseRuns\nFilterActive, FlattenCourseRuns exists(UnitedKingdomProviderReferenceNumber == ProviderUKPRN,\n\tnegate:false,\n\tbroadcast: 'auto')~> HasLiveCourses\nSortedProviders sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tpartitionFileNames:['providers.json'],\n\tpartitionBy('hash', 1),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> Cache"
		}
	}
}